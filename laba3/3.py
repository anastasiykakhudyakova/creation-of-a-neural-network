#Решите предыдущее задание, но уже с использованием кода и цикла в нём, 
#последовательно меняя вес на заданный шаг на каждой итерации.
#Выполнять цикл надо до тех пор, пока ошибка не станет меньше 0.001. 
#Выведите получившиеся веса.

# Импортируем библиотеку numpy для работы с массивами и математическими операциями
import numpy as np

# Функция нейронной сети: вычисляет выходное значение как скалярное произведение входов и весов
# inp - входные данные, weights - веса нейронной сети
def neural_networks(inp, weights):
    return inp.dot(weights)

# Функция вычисления ошибки: квадратичная ошибка между истинным значением и предсказанием
# true_predict - истинное значение, cur_predict - текущее предсказание
def get_error(true_predict, cur_predict):
    return (true_predict - cur_predict) ** 2

# Истинное значение, которое должна предсказать нейронная сеть
true_predict = 50

# Начальные веса нейронной сети: два веса для двух входных признаков
weights = np.array([0.2, 0.3])

# Входные данные для нейронной сети: два признака со значениями 150 и 40
inp = np.array([150, 40])

# Целевое значение ошибки, которое мы хотим достичь
ideal_error = 0.001

# Цикл while: выполняется до тех пор, пока текущая ошибка больше целевой (0.001)
# На каждой итерации вычисляется ошибка текущей модели и проверяется условие
while get_error(true_predict, neural_networks(inp, weights)) > ideal_error:
    # Увеличиваем первый вес на 0.0001 на каждой итерации цикла
    # Это шаг обучения - постепенная корректировка веса для уменьшения ошибки
    weights[0] += 0.0001
    
# После выхода из цикла (когда ошибка стала меньше 0.001) выводим найденные веса
print(weights)

# Выводим финальное значение ошибки для проверки, что оно действительно меньше 0.001
print(get_error(true_predict, neural_networks(inp, weights)))
