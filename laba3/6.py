#Измените количество итераций в цикле (например, увеличьте до 100). 
#Как изменение числа итераций влияет на точность предсказаний? 
#Попробуйте найти оптимальное количество итераций для данной задачи.            Влияет на точность результата. Чем больше эпох, тем меньше ошибка.

# Импортируем библиотеку numpy для математических операций
import numpy as np

# Функция нейронной сети: простейшая модель - умножение входа на вес
# inp - входное значение, weight - параметр (вес) нейросети
def neural_networks(inp, weight):
    return inp * weight

# Функция вычисления квадратичной ошибки
# true_prediction - целевое значение, prediction - предсказание нейросети
def get_error(true_prediction, prediction):
    return (true_prediction - prediction) ** 2

# Улучшенная функция градиентного спуска с параметром n - количество итераций
# inp - входное значение, weight - начальный вес
# true_prediction - целевое значение, n - количество итераций обучения
def gradient(inp, weight, true_prediction, n):
    # Цикл обучения выполняется n раз
    for i in range(n): 
        # Вычисляем предсказание нейросети с текущим весом
        prediction = neural_networks(inp, weight)
        # Вычисляем ошибку между целевым и предсказанным значениями
        error = get_error(true_prediction, prediction)
        # Выводим текущие значения для отслеживания процесса обучения
        # %.10f - вывод с 10 знаками после запятой для высокой точности
        print("Prediction: %.10f, Weight: %.5f, Error: %.20f" %(prediction, weight, error))
        # Вычисляем градиент (производную ошибки по весу)
        # Формула: delta = (prediction - true_prediction) * inp
        delta = (prediction - true_prediction) * inp
        # Обновляем вес по правилу градиентного спуска
        # Здесь learning_rate = 1 (неявно)
        weight = weight - delta

# простая задача с нормальными параметрами
# Параметры: вход=0.9, начальный вес=0.2, цель=0.5, итераций=15
# "достаточно 15" означает, что для сходимости хватит 15 итераций
gradient(0.9, 0.2, 0.5, 15)

# Пустая строка для разделения выводов
print()

#  сложная задача с экстремальными параметрами
# Параметры: очень маленький вход=0.009, очень маленький начальный вес=0.0001
# Цель=0.9 (очень далеко от начального предсказания), итераций=200,000
# "нужно больше 10**5" показывает, что для сходимости нужно много итераций
gradient(0.009, 0.0001, 0.9, 2 * 10 ** 5)
