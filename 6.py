#напишите код с циклом, где значение веса будет увеличиваться до тех пор, пока выходное значение меньше 0.5.
#Как только один выход стал больше 0.5, то изменение его веса останавливается. 
#Как только второй выход стал больше 0.5, то изменение его веса также останавливается, а цикл завершается. 
#Выведите получившиеся веса.
# Функция нейронной сети, которая умножает вход на каждый вес
def network(inp, weight):
    predict = [0] * len(weight)  # Создаем список нулей длиной равной количеству весов
    for i in range(len(predict)):
        predict[i] = inp * weight[i]  # Каждый выход = вход * соответствующий вес
    return predict  # Возвращаем список выходных значений
weight = [0.001, 0.5]  # Начальные значения двух весов
inp = 4  # Входное значение

STEP = 0.09  
MAX_PREDICT = 0.5  # Максимальное целевое значение выхода
predict = network(inp, weight)# Первый расчет выходных значений

# Главный цикл обучения - работает пока ХОТЯ БЫ один выход меньше 0.5
while predict[0] <= MAX_PREDICT or predict[1] <= MAX_PREDICT:
    # Увеличиваем weight[0] только если его выход еще не достиг 0.5
    weight[0] += STEP if predict[0] <= MAX_PREDICT else 0
    
    # Увеличиваем weight[1] только если его выход еще не достиг 0.5  
    weight[1] += STEP if predict[1] <= MAX_PREDICT else 0
    
    # Пересчитываем выходные значения с новыми весами
    predict = network(inp, weight)
    
# Вывод итоговых выходных значений
print(predict)
