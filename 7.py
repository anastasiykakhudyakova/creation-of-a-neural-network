#Добавьте еще один набор весов (weights_4 = [0.4, 0.2, 0.1]) и добавьте его в список weights. 
#Запустите функцию с этим новым набором весов. 
#Как это повлияло на предсказанные значения? Объясните, почему.

def network(inp, weight):
    predict = [0] * len(weight)
    # Создаем список predict, заполненный нулями, длиной равной количеству наборов весов
    # Каждый ноль будет заменен на результат вычисления для соответствующего набора весов
    
    for i in range(len(weight)):
        # Цикл по каждому набору весов (каждому "нейрону")
        predict[i] = sum([inp[j] * weight[i][j] for j in range(len(inp))])
        # Для каждого набора весов вычисляем взвешенную сумму:
    return predict
# Возвращаем список предсказаний

print("1")
# Вывод 1-го эксперимента
print(network([50, 165], [[0.2, 0.1], [0.3, 0.1]]))
# Вход: [50, 165], 2 набора весов по 2 веса в каждом
# Расчет: 
#   [50*0.2 + 165*0.1, 50*0.3 + 165*0.1] = [26.5, 31.5]

print("2")
# Вывод 2-го эксперимента
print(network([50, 165, 45], [[0.2, 0.1, 0.65], [0.3, 0.1, 0.7]]))
# Вход: [50, 165, 45], 2 набора весов по 3 веса в каждом
# Расчет:
#   [50*0.2 + 165*0.1 + 45*0.65, 50*0.3 + 165*0.1 + 45*0.7] = [55.75, 63.0]

print("3")
# Вывод 3-го эксперимента
print(network([50, 165, 45], [[0.2, 0.1, 0.65], [0.3, 0.1, 0.7], [0.5, 0.4, 0.34]]))
# Вход: [50, 165, 45], 3 набора весов по 3 веса в каждом
# Добавляется третий "нейрон" с весами [0.5, 0.4, 0.34]
# Расчет для третьего нейрона: 50*0.5 + 165*0.4 + 45*0.34 = 25 + 66 + 15.3 = 106.3

print("4")
# Вывод 4-го эксперимента 
print(network([50, 165, 45], [[0.2, 0.1, 0.65], [0.3, 0.1, 0.7], [0.5, 0.4, 0.34], [0.4, 0.2, 0.1]]))
# Вход: [50, 165, 45], 4 набора весов по 3 веса в каждом
# Добавляется четвертый "нейрон" с весами [0.4, 0.2, 0.1]
# Расчет для четвертого нейрона: 50*0.4 + 165*0.2 + 45*0.1 = 20 + 33 + 4.5 = 57.5

#Добавление нового набора весов не изменило предыдущие предсказания, а добавило новое значение в результат, соответствующее взвешенной сумме входов с новыми весами
