""" задание"""
# нейросеть, которая будет суммировать 2 числа.
#То есть на входе у неё будет 2 нейрона, например: [10, 5], [0, -5], [2, 6],
#а на выходе должен быть 1 нейрон. Для представленных входов,
#выходы будут: [15], [-5], [8] соответственно.
#Проверьте правильность работы нейросети, передав ей тестовые данные [12, 4]
#на вход, а потом [3, -8].
#Примечание: регулируйте параметры нейросети до тех пор,
#пока она не будет выдавать результат для тестовых данных очень близкий к правильному
#(ошибка не должна быть больше 1%).

import numpy as np
# Функция нейронной сети - простая линейная модель
# inp - входные данные (два числа для сложения), weights - веса
# Возвращает линейную комбинацию: inp[0]*weights[0] + inp[1]*weights[1]
def neural_networks(inp, weights):
    return inp.dot(weights)  # Скалярное произведение

# Функция вычисления ошибки (псевдо-RMSE)
# true_prediction - правильная сумма, prediction - предсказанная сумма
# Возвращает квадратный корень из среднего квадрата ошибки (для одного значения)
def get_error(true_prediction, prediction):
    return np.sqrt(np.mean((true_prediction - prediction) ** 2))

# Функция градиентного спуска для обучения нейросети
# inp - массив входных данных, weights - веса нейросети
# true_predict - правильные суммы, learn_rate - скорость обучения
# epochs - количество эпох обучения
def gradient(inp, weights, true_predict, learn_rate, epochs):
    # Цикл обучения по количеству эпох
    for _ in range(epochs):
        error = 0  # Общая ошибка за эпоху
        delta = np.zeros_like(weights)  # Аккумулятор для градиентов
        
        # Проход по всем примерам обучающей выборки
        for j in range(len(inp)):
            cur_inp = inp[j]  # Текущая пара чисел для сложения
            cur_true_predict = true_predict[j]  # Правильная сумма для этой пары
            predict = neural_networks(cur_inp, weights)  # Предсказание нейросети
            
            # Накопление ошибки для мониторинга
            error += get_error(cur_true_predict, predict)
            
            # Вывод отладочной информации
            print(
                "Prediction: %.10f, True_prediction: %.10f, Weights: %s"
                % (predict, cur_true_predict, weights)
            )
            
            # Вычисление градиента для текущего примера
            # Градиент = (предсказание - правильное_значение) * входные_данные
            delta += (predict - cur_true_predict) * cur_inp * learn_rate
        
        # Обновление весов: вычитаем средний градиент по всем примерам
        weights -= delta / len(inp)
        
        # Вывод общей ошибки за эпоху
        print("Errors: %.10f" % error)
        print("-------------------")  # Разделитель между эпохами
    
    # Возвращаем обученные веса
    return weights

# Функция для вычисления суммы двух чисел с помощью обученной нейросети
# a - первое число, b - второе число, weights - обученные веса
def calc_sum(a, b, weights):
    return neural_networks(np.array([a, b]), weights)

# Функция для вычисления относительной разницы в процентах
# a - правильное значение, b - предсказанное значение
def get_diff(a, b):
    return abs(a - b) / 100  # ВНИМАНИЕ: здесь ошибка - должно быть /a*100 для процентов

# Функция для тестирования нейросети на конкретной паре чисел
# a - первое число, b - второе число, weights - обученные веса
def solve(a, b, weights):
    ans_from_NN = calc_sum(a, b, weights)  # Сумма от нейросети
    ans = a + b  # Правильная сумма
    diff_ans = get_diff(ans, ans_from_NN)  # Вычисление разницы (с ошибкой)
    
    # Вывод результатов тестирования
    print("data: ", a, b)
    print("ans from neural network: ", ans_from_NN)
    print("correct ans: ", ans)
    print("difference: ", diff_ans)
    print("-------------------")

# Основная функция программы
def main():
    # Обучающая выборка: пары чисел и их суммы
    inp = np.array([[10, 5], [0, -5], [2, 6]])
    
    # Начальные веса нейросети (случайные значения)
    weights = np.array([0.2, 0.3])
    
    # Правильные суммы для обучающей выборки
    true_predict = np.array([15, -5, 8])
    
    # Гиперпараметры обучения
    learn_rate = 0.00001  # Скорость обучения
    epochs = 10**4  # Количество эпох обучения (10000)
    
    # Обучение нейросети
    weights = gradient(inp, weights, true_predict, learn_rate, epochs)
    
    # Тестирование обученной нейросети
    solve(12, 4, weights)  # Ожидается 16
    solve(3, -8, weights)  # Ожидается -5

# Запуск основной функции
main()


