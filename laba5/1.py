#Создание нейросети, определяющей пол человека по весу и росту
#За основу берем нейронку из прошлого занятия, где мы рассматривали обучение на наборе данных

'''задание'''
#Напишите по памяти код из урока "Создание нейросети, определяющей пол человека по весу и росту".
import numpy as np# Импорт библиотеки numpy для работы с массивами и математическими операциями

# Функция нейронной сети - выполняет линейное преобразование
# inp - входные данные (рост и вес), weights - весовые коэффициенты
# Возвращает скалярное произведение входов и весов
def neural_networks(inp, weights):
    return inp.dot(weights)  # Линейная комбинация: inp[0]*weights[0] + inp[1]*weights[1]

# Функция вычисления ошибки (квадратичная ошибка)
# true_prediction - целевое значение, prediction - предсказание сети
# Возвращает квадрат разности между целевым и предсказанным значениями
def get_error(true_prediction, prediction):
    return (true_prediction - prediction) ** 2


#Объявим несколько наборов данных на два входа
# Создаем массив входных данных (рост в см, вес в кг)
# Каждая строка - один пример для обучения
inp = np.array([
    [150, 40],  # Низкий рост, маленький вес (женщина)
    [140, 35],  # Низкий рост, очень маленький вес (женщина)
    [155, 45],  # Средний рост, небольшой вес (женщина)
    [185, 95],  # Высокий рост, большой вес (мужчина)
    [145, 40],  # Низкий рост, небольшой вес (женщина)
    [195, 100], # Очень высокий рост, очень большой вес (мужчина)
    [180, 95],  # Высокий рост, большой вес (мужчина)
    [170, 80],  # Средний рост, средний вес (мужчина)
    [160, 90],  # Средний рост, большой вес (мужчина)
])

# Инициализация весовых коэффициентов (случайные начальные значения)
# weights[0] - вес для роста, weights[1] - вес для веса
weights = np.array([0.2, 0.3])

# Целевые значения (правильные ответы для обучения)
# 0 - женщина, 100 - мужчина (используется 100 вместо 1 для масштабирования)
true_predictions = np.array([0, 0, 0, 100, 0, 100, 100, 100, 100])

# Скорость обучения - гиперпараметр, определяющий размер шага при обновлении весов
learning_rate = 0.00001

# Начинаем процесс обучения (500 эпох - полных проходов по всем данным)
for i in range(500):
    error = 0  # Обнуляем суммарную ошибку для текущей эпохи
    delta = np.zeros_like(weights)  # Создаем нулевой массив для накопления градиентов
  
    #Приступаем к обучениюю применим полный градиентный спуск
    # Проходим по всем примерам обучающей выборки
    for j in range(len(inp)):
        current_inp = inp[j]  # Текущий входной вектор (рост и вес)
        true_prediction = true_predictions[j]  # Целевое значение для текущего примера
        prediction = neural_networks(current_inp, weights)  # Предсказание сети
        error += get_error(true_prediction, prediction)  # Накопление ошибки
        print("Prediction: %.10f, True_prediction: %.10f, Weights: %s" % (prediction, true_prediction, weights)) # Вывод отладочной информации 
        
        # Вычисление градиента для текущего примера и добавление к общему градиенту
        delta += (prediction - true_prediction) * current_inp * learning_rate
    
    # Обновление весов: вычитаем среднее значение градиента по всем примерам
    weights -= delta / len(inp)
    
    # Вывод суммарной ошибки для текущей эпохи
    print("Errors: %.10f" % error)
    print("-------------------")  # Разделитель между эпохами

# Тестирование обученной модели на новых данных
# Первый тест: 150 см, 45 кг (ожидается женщина - значение ближе к 0)
print(neural_networks(np.array([150,45]), weights))

# Второй тест: 170 см, 85 кг (ожидается мужчина - значение ближе к 100)
print(neural_networks(np.array([170,85]), weights))
