#Добавьте еще один скрытый слой к нейросети. 
#Создайте третий набор весов weights_h_3 = [0.6, 0.2] и weights_out_3 = [0.7, 0.4]. 
#Добавьте его в переменные weights_h и weights_out. 
#Измените функцию neural_network так, чтобы она работала с этим третьим слоем.
import numpy as np #Импорт библиотеки NumPy для работы с массивами и линейной алгеброй, что необходимо для эффективных матричных операций в нейросетях.

def neuralNetwork(inp, weights):
  # Трехслойная нейросеть: вход -> скрытый слой 1 -> скрытый слой 2 -> скрытый слой 3 -> выход
    prediction_h1 = inp.dot(weights[0])  # Вход -> Скрытый слой 1 Первый скрытый слой. Умножение входного вектора на матрицу весов первого слоя
    prediction_h2 = prediction_h1.dot(weights[1])  # Скрытый слой 1 -> Скрытый слой 2 Второй скрытый слой. Вектор из первого скрытого слоя умножается на матрицу весов второго слоя для получения активаций второго скрытого слоя.
    prediction_h3 = prediction_h2.dot(weights[2])  # Скрытый слой 2 -> Скрытый слой 3
    prediction_out = prediction_h3.dot(weights[3])  # Скрытый слой 3 -> Выход Выходной слой. Вектор из второго скрытого слоя умножается на матрицу весов выходного слоя для получения окончательного предсказания.
    return prediction_out #Возврат результата нейросети.

inp = np.array([23, 45]) #Создание входного вектора с двумя признаками

# Веса для 3-х скрытых слоев (каждый слой имеет разное количество нейронов):
# Скрытый слой 1: 2 входа -> 3 нейрона
weight_h1 = np.array([[0.4, 0.1],   # Веса для нейрона 1
                      [0.3, 0.2],   # Веса для нейрона 2
                      [0.6, 0.2]])  # Веса для нейрона 3 (добавлен третий набор весов)
# Скрытый слой 2: 3 входа -> 2 нейрона
weight_h2 = np.array([[0.2, 0.5, 0.3],   # Веса для нейрона 1
                      [0.4, 0.1, 0.6]])  # Веса для нейрона 2

# Скрытый слой 3: 2 входа -> 3 нейрона (третий скрытый слой)
weight_h3 = np.array([[0.7, 0.4],   # Веса для нейрона 1
                      [0.5, 0.2],   # Веса для нейрона 2
                      [0.3, 0.8]])  # Веса для нейрона 3

# Выходной слой: 3 входа -> 2 нейрона
weight_out = np.array([[0.7, 0.4, 0.1],   # Веса для выходного нейрона 1
                       [0.3, 0.5, 0.9]])  # Веса для выходного нейрона 2
#Веса для выходного слоя. Каждый выходной нейрон имеет веса для соединений со скрытым слоем.


weight_out_1 = [0.4, 0.1]
weight_out_2 = [0.3, 0.1]
weight_out_3 = [0.7, 0.4]
weights_h = np.array([weight_h_1, weight_h_2, weight_h_3]).T #транспонируем весовые матрицы (матрица 2×3 для первого скрытого слоя (2 входа, 3 нейрона))
weights_out = np.array([weight_out_1, weight_out_2, weight_out_3]).T #транспонируем весовые матрицы (матрица 3×3 для выходного слоя (3 входа от скрытого слоя, 3 выходных нейрона))
#(.T - транспонирование для правильной размерности)

#Создание матриц для трехслойной архитектуры:
weights_1 = np.array([weight_h_1, weight_h_2]).T       # 2×2 матрица от входного к первому скрытому слою (2 нейрона)
weights_2 = np.array([weight_h_3, weight_out_1]).T     #2×2 матрица между слоями 
weights_3 = np.array([weight_out_2, weight_out_3]).T   # 2×2 матрица для выходного слоя

weights = [weights_1, weights_2, weights_3]  #Объединение всех матриц весов в список для передачи в нейросеть.

print(neuralNetwork(inp, weights))


